import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';
import { NotificationGateway } from '../notifications/notification.gateway';

interface AuthenticatedSocket extends Socket {
  userId?: string;
  userRole?: 'patient' | 'doctor';
}

@WebSocketGateway({
  cors: {
    origin: '*',
    methods: ['GET', 'POST'],
  },
  namespace: '/appointments',
})
export class AppointmentNotificationGateway
  implements OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger(AppointmentNotificationGateway.name);
  private connectedUsers: Map<string, string> = new Map(); // userId -> socketId

  constructor(private readonly notificationGateway: NotificationGateway) {}

  async handleConnection(client: AuthenticatedSocket) {
    try {
      const userId = client.handshake.auth.userId;
      const userRole = client.handshake.auth.userRole;

      if (!userId || !userRole) {
        this.logger.warn('Connection rejected: Missing userId or userRole');
        client.disconnect();
        return;
      }

      client.userId = userId;
      client.userRole = userRole as 'patient' | 'doctor';

      // Store connection
      this.connectedUsers.set(userId, client.id);

      // Join user to their personal room
      client.join(`user_${userId}`);

      this.logger.log(
        `User ${userId} (${userRole}) connected to appointment notifications`,
      );
    } catch (error) {
      this.logger.error('Connection error:', error);
      client.disconnect();
    }
  }

  handleDisconnect(client: AuthenticatedSocket) {
    if (client.userId) {
      this.connectedUsers.delete(client.userId);
      this.logger.log(`User ${client.userId} disconnected from appointments`);
    }
  }

  /**
   * Notify doctor about new appointment
   */
  async notifyDoctorNewAppointment(doctorId: string, appointment: any) {
    // Send real-time socket notification
    this.server.to(`user_${doctorId}`).emit('appointment:new', {
      type: 'NEW_APPOINTMENT',
      appointment,
      message: 'B·∫°n c√≥ l·ªãch h·∫πn m·ªõi',
      timestamp: new Date(),
    });

    // Create persistent notification (without socket emit)
    const savedNotification =
      await this.notificationGateway.sendNotificationToUser(
        doctorId,
        {
          title: 'üìÖ L·ªãch h·∫πn m·ªõi',
          message: `B·∫°n c√≥ l·ªãch h·∫πn m·ªõi t·ª´ b·ªánh nh√¢n ${appointment.patientName || 'N/A'}`,
          type: 'APPOINTMENT_NEW',
          data: { appointmentId: appointment._id },
          linkTo: '/doctor/schedule',
          icon: 'üìÖ',
        },
        false,
      ); // ‚úÖ Pass false to skip socket emit

    // Emit notification:new via this gateway (same socket connection)
    this.server.to(`user_${doctorId}`).emit('notification:new', {
      ...savedNotification.toObject(),
      timestamp: new Date(),
    });

    this.logger.log(`Notified doctor ${doctorId} about new appointment`);
  }

  /**
   * Notify patient about appointment confirmation
   */
  async notifyPatientAppointmentConfirmed(patientId: string, appointment: any) {
    // Send real-time socket notification
    this.server.to(`user_${patientId}`).emit('appointment:confirmed', {
      type: 'APPOINTMENT_CONFIRMED',
      appointment,
      message: 'L·ªãch h·∫πn c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n',
      timestamp: new Date(),
    });

    // Create persistent notification (without socket emit)
    const savedNotification =
      await this.notificationGateway.sendNotificationToUser(
        patientId,
        {
          title: '‚úÖ L·ªãch h·∫πn ƒë√£ x√°c nh·∫≠n',
          message: `B√°c sƒ© ${appointment.doctorName || 'N/A'} ƒë√£ x√°c nh·∫≠n l·ªãch h·∫πn c·ªßa b·∫°n`,
          type: 'APPOINTMENT_CONFIRMED',
          data: { appointmentId: appointment._id },
          linkTo: '/patient/appointments/my-appointments',
          icon: '‚úÖ',
        },
        false,
      );

    // Emit notification:new via this gateway
    this.server.to(`user_${patientId}`).emit('notification:new', {
      ...savedNotification.toObject(),
      timestamp: new Date(),
    });

    this.logger.log(`Notified patient ${patientId} about confirmation`);
  }

  /**
   * Notify about appointment cancellation
   */
  /**
   * Notify about appointment cancellation (ENHANCED with billing info)
   */
  async notifyAppointmentCancelled(
    userId: string,
    appointment: any,
    cancelledBy: 'doctor' | 'patient' | 'system',
    feeCharged = false,
    voucherCreated = false,
  ) {
    let message = '';

    // Build message based on who cancelled
    if (cancelledBy === 'system') {
      message = 'H·ªá th·ªëng ƒë√£ t·ª± ƒë·ªông h·ªßy l·ªãch h·∫πn do b√°c sƒ© kh√¥ng k·ªãp x√°c nh·∫≠n';
    } else if (cancelledBy === 'doctor') {
      message = 'B√°c sƒ© ƒë√£ h·ªßy l·ªãch h·∫πn';
    } else {
      message = 'B·ªánh nh√¢n ƒë√£ h·ªßy l·ªãch h·∫πn';
    }

    if (feeCharged) {
      message += '. Ph√≠ ƒë·∫∑t ch·ªó 100,000 VND ƒë∆∞·ª£c √°p d·ª•ng';
    }
    if (voucherCreated) {
      message += '. B·∫°n ƒë√£ nh·∫≠n voucher gi·∫£m gi√° 5%';
    }

    // Send real-time socket notification
    this.server.to(`user_${userId}`).emit('appointment:cancelled', {
      type: 'APPOINTMENT_CANCELLED',
      appointment,
      cancelledBy,
      feeCharged,
      voucherCreated,
      message,
      timestamp: new Date(),
    });

    // Create persistent notification (without socket emit)
    const savedNotification =
      await this.notificationGateway.sendNotificationToUser(
        userId,
        {
          title:
            cancelledBy === 'system'
              ? '‚ö†Ô∏è H·ªá th·ªëng h·ªßy l·ªãch h·∫πn'
              : '‚ùå L·ªãch h·∫πn ƒë√£ b·ªã h·ªßy',
          message,
          type: 'APPOINTMENT_CANCELLED',
          data: {
            appointmentId: appointment._id,
            cancelledBy,
            feeCharged,
            voucherCreated,
          },
          linkTo:
            cancelledBy === 'patient'
              ? '/doctor/schedule'
              : '/patient/appointments/my-appointments',
          icon: cancelledBy === 'system' ? '‚ö†Ô∏è' : '‚ùå',
        },
        false,
      );

    // Emit notification:new via this gateway
    this.server.to(`user_${userId}`).emit('notification:new', {
      ...savedNotification.toObject(),
      timestamp: new Date(),
    });

    this.logger.log(`Notified user ${userId} about cancellation`);
  }

  /**
   * Notify about appointment reschedule (ENHANCED with fee info)
   */
  async notifyAppointmentRescheduled(
    userId: string,
    appointment: any,
    userRole: 'doctor' | 'patient' = 'patient',
    feeCharged = false,
  ) {
    let message = 'L·ªãch h·∫πn ƒë√£ ƒë∆∞·ª£c d·ªùi sang th·ªùi gian kh√°c';
    if (feeCharged) {
      message +=
        '. Ph√≠ ƒë·∫∑t ch·ªó 100,000 VND ƒë∆∞·ª£c √°p d·ª•ng do ƒë·ªïi l·ªãch trong v√≤ng 30 ph√∫t';
    }

    // Send real-time socket notification
    this.server.to(`user_${userId}`).emit('appointment:rescheduled', {
      type: 'APPOINTMENT_RESCHEDULED',
      appointment,
      feeCharged,
      message,
      timestamp: new Date(),
    });

    // Create persistent notification (without socket emit)
    const savedNotification =
      await this.notificationGateway.sendNotificationToUser(
        userId,
        {
          title: 'üîÑ L·ªãch h·∫πn ƒë√£ ƒë∆∞·ª£c d·ªùi',
          message,
          type: 'APPOINTMENT_RESCHEDULED',
          data: { appointmentId: appointment._id, feeCharged },
          linkTo:
            userRole === 'doctor'
              ? '/doctor/schedule'
              : '/patient/appointments/my-appointments',
          icon: 'üîÑ',
        },
        false,
      );

    // Emit notification:new via this gateway
    this.server.to(`user_${userId}`).emit('notification:new', {
      ...savedNotification.toObject(),
      timestamp: new Date(),
    });

    this.logger.log(`Notified user ${userId} about reschedule`);
  }

  /**
   * Notify patient about appointment completion
   */
  async notifyAppointmentCompleted(patientId: string, appointment: any) {
    // Send real-time socket notification
    this.server.to(`user_${patientId}`).emit('appointment:completed', {
      type: 'APPOINTMENT_COMPLETED',
      appointment,
      message: 'L·ªãch kh√°m ƒë√£ ho√†n t·∫•t',
      timestamp: new Date(),
    });

    // Create persistent notification (without socket emit)
    const savedNotification =
      await this.notificationGateway.sendNotificationToUser(
        patientId,
        {
          title: '‚úÖ L·ªãch kh√°m ho√†n t·∫•t',
          message: 'L·ªãch kh√°m ƒë√£ ho√†n t·∫•t. B·∫°n c√≥ th·ªÉ xem h·ªì s∆° b·ªánh √°n.',
          type: 'APPOINTMENT_COMPLETED',
          data: { appointmentId: appointment._id },
          linkTo: '/patient/medical-records',
          icon: '‚úÖ',
        },
        false,
      );

    // Emit notification:new via this gateway
    this.server.to(`user_${patientId}`).emit('notification:new', {
      ...savedNotification.toObject(),
      timestamp: new Date(),
    });

    this.logger.log(`Notified patient ${patientId} about completion`);
  }

  /**
   * Send appointment reminder (30 minutes before)
   */
  async sendAppointmentReminder(userId: string, reminderData: any) {
    // Send real-time socket notification
    this.server.to(`user_${userId}`).emit('appointment:reminder', {
      type: 'APPOINTMENT_REMINDER',
      ...reminderData,
      timestamp: new Date(),
    });

    // Create persistent notification (without socket emit)
    const savedNotification =
      await this.notificationGateway.sendNotificationToUser(
        userId,
        {
          title: '‚è∞ Nh·∫Øc nh·ªü l·ªãch h·∫πn',
          message:
            reminderData.message ||
            'L·ªãch h·∫πn c·ªßa b·∫°n s·∫Øp b·∫Øt ƒë·∫ßu trong 30 ph√∫t',
          type: 'APPOINTMENT_REMINDER',
          data: { appointmentId: reminderData.appointmentId },
          linkTo: reminderData.linkTo,
          icon: '‚è∞',
        },
        false,
      );

    // Emit notification:new via this gateway
    this.server.to(`user_${userId}`).emit('notification:new', {
      ...savedNotification.toObject(),
      timestamp: new Date(),
    });

    this.logger.log(`Sent reminder to user ${userId}`);
  }

  /**
   * Notify follow-up suggestion
   */
  async notifyFollowUpSuggestion(appointment: any) {
    const patientId = appointment.patientId?._id || appointment.patientId;

    this.server.to(`user_${patientId}`).emit('appointment:followup', {
      type: 'FOLLOW_UP_SUGGESTION',
      appointment,
      message: 'B√°c sƒ© ƒë·ªÅ xu·∫•t l·ªãch t√°i kh√°m v·ªõi gi·∫£m gi√° 5%',
      timestamp: new Date(),
    });

    await this.notificationGateway.sendNotificationToUser(
      String(patientId),
      {
        title: 'üîî ƒê·ªÅ xu·∫•t t√°i kh√°m',
        message:
          'B√°c sƒ© ƒë√£ ƒë·ªÅ xu·∫•t l·ªãch t√°i kh√°m cho b·∫°n v·ªõi ∆∞u ƒë√£i gi·∫£m gi√° 5%',
        type: 'FOLLOW_UP_SUGGESTION',
        data: { appointmentId: appointment._id },
        linkTo: '/patient/appointments?tab=follow-ups',
        icon: 'üîî',
      },
      false,
    );
  }

  /**
   * Notify doctor when patient confirms follow-up
   */
  async notifyFollowUpConfirmed(doctorId: string, appointment: any) {
    this.server.to(`user_${doctorId}`).emit('appointment:followup-confirmed', {
      type: 'FOLLOW_UP_CONFIRMED',
      appointment,
      message: 'B·ªánh nh√¢n ƒë√£ x√°c nh·∫≠n l·ªãch t√°i kh√°m',
      timestamp: new Date(),
    });

    await this.notificationGateway.sendNotificationToUser(
      doctorId,
      {
        title: '‚úÖ X√°c nh·∫≠n l·ªãch t√°i kh√°m',
        message: `B·ªánh nh√¢n ${appointment.patientId?.fullName || 'ƒë√£ x√°c nh·∫≠n'} l·ªãch t√°i kh√°m`,
        type: 'FOLLOW_UP_CONFIRMED',
        data: { appointmentId: appointment._id },
        linkTo: '/doctor/schedule',
        icon: '‚úÖ',
      },
      false,
    );
  }

  /**
   * Notify doctor when patient rejects follow-up
   */
  async notifyFollowUpRejected(doctorId: string, appointment: any) {
    this.server.to(`user_${doctorId}`).emit('appointment:followup-rejected', {
      type: 'FOLLOW_UP_REJECTED',
      appointment,
      message: 'B·ªánh nh√¢n ƒë√£ t·ª´ ch·ªëi l·ªãch t√°i kh√°m',
      timestamp: new Date(),
    });

    await this.notificationGateway.sendNotificationToUser(
      doctorId,
      {
        title: '‚ùå T·ª´ ch·ªëi l·ªãch t√°i kh√°m',
        message: `B·ªánh nh√¢n ${appointment.patientId?.fullName || 'ƒë√£ t·ª´ ch·ªëi'} l·ªãch t√°i kh√°m`,
        type: 'FOLLOW_UP_REJECTED',
        data: { appointmentId: appointment._id },
        linkTo: '/doctor/schedule',
        icon: '‚ùå',
      },
      false,
    );
  }

  /**
   * Check if user is online
   */
  isUserOnline(userId: string): boolean {
    return this.connectedUsers.has(userId);
  }
}
